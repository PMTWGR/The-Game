<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Industry Chess</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      margin: 0; 
      padding: 10px;
      background-color: #f0f0f0; 
      box-sizing: border-box;
    }
    #game { 
      display: flex; 
      gap: 10px; 
      width: 100%;
      max-width: 1200px;
      flex-direction: column;
    }
    #board-container {
      width: 100%;
      aspect-ratio: 1/1;
      max-width: 560px;
      margin: 0 auto;
    }
    #board { 
      border: 2px solid #333; 
      width: 100%;
      height: 100%;
      display: block;
    }
    #controls { 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
      margin-top: 10px;
      width: 100%;
      max-width: 560px;
      margin: 10px auto 0 auto;
    }
    #educationalContent { 
      flex-grow: 1; 
      overflow-y: auto; 
      border: 1px solid #333; 
      padding: 8px; 
      margin: 2px 0; 
      line-height: 1.3;
      min-height: 80px;
      max-height: 150px;
      background: white;
    }
    .insight { margin: 4px 0; }
    .valid-move { fill: rgba(0, 255, 0, 0.5); cursor: pointer; }
    button { 
      padding: 8px 12px; 
      font-size: 16px; 
      cursor: pointer; 
      margin: 2px 0; 
      border: 1px solid #333;
      border-radius: 0px;
      background-color: #fff;
      color: #000;
    }
    select { 
      padding: 8px 12px; 
      font-size: 16px; 
      margin: 2px 0; 
      border: 1px solid #333;
      border-radius: 0px;
      background-color: #fff;
    }
    image { pointer-events: auto; }
    #imageErrors { display: none; }
    .whiteAuto { filter: invert(1) grayscale(0.7) brightness(1.1) contrast(2.0) drop-shadow(0 0 2px #000); }
    .legend { font-size: 12px; margin: 2px 0; }
    .popup-image {
      position: absolute;
      width: 210px;
      height: 210px;
      z-index: 10;
      pointer-events: none;
      display: none;
      border: 2px solid #333;
      opacity: 0.7;
    }
    
    /* Comment Section Styles */
    #commentSection {
      border: 1px solid #333;
      padding: 15px;
      background: white;
      margin-top: 10px;
    }
    #commentSection h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #000;
    }
    #commentForm {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    #commentForm input,
    #commentForm textarea {
      padding: 8px;
      border: 1px solid #333;
      background: white;
      color: #000;
      font-family: Arial, sans-serif;
      font-size: 14px;
    }
    #commentForm textarea {
      min-height: 60px;
      resize: vertical;
    }
    #commentForm button {
      align-self: flex-start;
    }
    .comment {
      border-bottom: 1px solid #ddd;
      padding: 8px 0;
      margin: 8px 0;
    }
    .comment:last-child {
      border-bottom: none;
    }
    .comment-username {
      font-weight: bold;
      color: #000;
    }
    .comment-text {
      color: #333;
      margin: 4px 0;
    }
    .comment-meta {
      font-size: 12px;
      color: #666;
    }
    
    @media (min-width: 768px) {
      #game {
        flex-direction: row;
        align-items: flex-start;
      }
      #controls {
        margin-top: 0;
        margin-left: 10px;
        min-width: 200px;
      }
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="board-container">
      <svg id="board" viewBox="0 0 560 560">
        <g id="boardSquares"></g>
        <g id="pieces"></g>
        <g id="popupLayer"></g>
        <g id="validMoves"></g>
      </svg>
    </div>
    <div id="controls">
      <button id="newBtn">New Game</button>
      <button id="undoBtn">Undo Move</button>
      <button id="aiBtn">AI Move</button>
      <select id="aiPersonality">
        <option value="major">Major Label</option>
        <option value="tech">Tech Platform</option>
      </select>
      <div id="aiThinking"></div>
      <div id="educationalContent"></div>
      <div id="imageErrors"></div>
      
      <!-- Comment Section -->
   <div id="commentSection">
  <h3>Community Insights</h3>
  <div id="commentForm">
    <input type="text" id="commentUsername" placeholder="Username (optional)" maxlength="20">
    <textarea id="commentText" placeholder="What does this game reveal to you about the music industry?"></textarea>
    <label style="font-size: 12px;">
      <input type="checkbox" id="commentPublic" checked>
      Share publicly
    </label>
    <button onclick="submitComment()">Share Insight</button>
  </div>
  <div id="commentsList" style="margin-top: 15px; max-height: 200px; overflow-y: auto;"></div>
</div>
    </div>
  </div>

  <script>
    const NS = "http://www.w3.org/2000/svg";
    const BASE_SQUARE = 70;
    const ASSET_DIR = "https://pmtwgr.github.io/The-Game/image/";
    const V = "?v=11";
    const DEBUG = true;

    // Airtable Configuration - REPLACE WITH YOUR REAL KEY LOCALLY
    const AIRTABLE_CONFIG = {
        BASE_ID: 'appHesCUB8Nu1xVK1',
        TABLE_NAME: 'CommunityInsights',
        API_KEY: 'YOUR_API_KEY_HERE'
    };

    function spriteFor(pieceChar, isBlack = false) {
      const isWhite = (pieceChar === pieceChar.toLowerCase());
      const color = isBlack || !isWhite ? "black-" : "white-";
      const typeMap = { p: "pawn", r: "rook", n: "knight", b: "bishop", q: "queen", k: "king" };
      const type = typeMap[pieceChar.toLowerCase()];
      const sprite = ASSET_DIR + color + type + ".png" + V;
      return sprite;
    }

    const state = {
      board: [],
      currentPlayer: 'white',
      selected: null,
      validMoves: [],
      aiThinking: false,
      gameOver: false,
      firstMoveMade: false
    };

    const aiPersonalities = {
      major: { name: "Major Label", style: "Market consolidation", risk: 0.55, focus: "control", depth: 3 },
      tech: { name: "Tech Platform", style: "Industry disruption", risk: 0.75, focus: "innovation", depth: 2 }
    };

    window.addEventListener('load', () => {
      document.getElementById('newBtn').onclick = resetGame;
      document.getElementById('undoBtn').onclick = undoMove;
      document.getElementById('aiBtn').onclick = makeAIMove;
      document.getElementById('aiPersonality').addEventListener('change', () => {
        const persona = aiPersonalities[document.getElementById('aiPersonality').value];
        setThinking(`${persona.name}: ${persona.style}. Focus: ${persona.focus}.`);
      });
      init();
      loadComments(); // Load existing comments on startup
    });

    function init() {
      buildBoard();
      setup();
      drawAll();
      pushEdu("Game started. You control White (Artists).");
      const initialPersona = aiPersonalities[document.getElementById('aiPersonality').value];
      setThinking(`${initialPersona.name}: ${initialPersona.style}. Focus: ${initialPersona.focus}.`);
    }

    function buildBoard() {
      const g = document.getElementById('boardSquares');
      g.innerHTML = '';
      state.board = Array.from({ length: 8 }, () => Array(8).fill(null));
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const sq = document.createElementNS(NS, 'rect');
          sq.setAttribute('x', c * BASE_SQUARE);
          sq.setAttribute('y', r * BASE_SQUARE);
          sq.setAttribute('width', BASE_SQUARE);
          sq.setAttribute('height', BASE_SQUARE);
          sq.setAttribute('fill', (r + c) % 2 === 0 ? '#fff' : '#eee');
          sq.setAttribute('stroke', '#000');
          sq.addEventListener('click', (e) => {
            onSquare(r, c);
          });
          g.appendChild(sq);
        }
      }
    }

    function setup() {
      placeRow(0, 'black', ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']);
      placeRow(1, 'black', Array(8).fill('p'));
      placeRow(6, 'white', Array(8).fill('p'));
      placeRow(7, 'white', ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']);
    }

    function placeRow(row, color, arr) {
      for (let c = 0; c < 8; c++) {
        state.board[row][c] = (color === 'white') ? arr[c] : arr[c].toUpperCase();
      }
    }

    function squareToAlgebraic(r, c) {
      return `${String.fromCharCode(97 + c)}${8 - r}`;
    }

    function drawAll() {
      drawPieces();
      showValid();
    }

    function drawPieces() {
      const g = document.getElementById('pieces');
      const popupLayer = document.getElementById('popupLayer');
      popupLayer.innerHTML = '';
      g.innerHTML = '';
      const errorDiv = document.getElementById('imageErrors');
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = state.board[r][c];
          if (!p) continue;
          const img = document.createElementNS(NS, 'image');
          const src = spriteFor(p);
          img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);
          img.setAttribute('href', src);
          img.setAttribute('x', c * BASE_SQUARE + 5);
          img.setAttribute('y', r * BASE_SQUARE + 5);
          img.setAttribute('width', BASE_SQUARE - 10);
          img.setAttribute('height', BASE_SQUARE - 10); // FIXED: was SQUARE, now BASE_SQUARE
          if (p === p.toLowerCase()) {
            img.addEventListener('error', () => {
              errorDiv.innerHTML += `<p>Error loading image for ${p} at ${squareToAlgebraic(r, c)}: ${src}</p>`;
              const blackSrc = ASSET_DIR + 'black-' + ({p:'pawn',r:'rook',n:'knight',b:'bishop',q:'queen',k:'king'}[p]) + '.png' + V;
              img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', blackSrc);
              img.setAttribute('href', blackSrc);
              img.classList.add('whiteAuto');
            }, { once: true });
            img.addEventListener('mouseover', () => {
              const popup = document.createElementNS(NS, 'image');
              const isWhite = p === p.toLowerCase();
              const popupSrc = spriteFor(p);
              popup.setAttributeNS('http://www.w3.org/1999/xlink', 'href', popupSrc);
              popup.setAttribute('href', popupSrc);
              popup.setAttribute('class', 'popup-image');
              popup.setAttribute('x', c * BASE_SQUARE - 70);
              popup.setAttribute('y', r * BASE_SQUARE - 215);
              popup.setAttribute('width', 210);
              popup.setAttribute('height', 210);
              popup.style.display = 'inline';
              popupLayer.appendChild(popup);
            });
            img.addEventListener('mouseout', () => {
              popupLayer.innerHTML = '';
            });
            img.addEventListener('click', (e) => {
              e.stopPropagation();
              onSquare(r, c);
            });
          } else {
            img.addEventListener('click', (e) => {
              e.stopPropagation();
              onSquare(r, c);
            });
          }
          g.appendChild(img);
        }
      }
    }

    function onSquare(r, c) {
      if (state.aiThinking || state.gameOver) return;
      const piece = state.board[r][c];
      
      if (state.selected) {
        const [sr, sc] = state.selected;
        const selectedPiece = state.board[sr][sc];
        const mv = state.validMoves.find(m => m.to[0] === r && m.to[1] === c);
        if (mv) {
          applyMove(mv);
          return;
        }
        state.selected = null;
        state.validMoves = [];
        showValid();
      }

      if (piece) {
        const isWhite = piece === piece.toLowerCase();
        if ((state.currentPlayer === 'white' && isWhite) || (state.currentPlayer === 'black' && !isWhite)) {
          state.selected = [r, c];
          state.validMoves = genMoves(r, c);
          showValid();
        }
      }
    }

    function showValid() {
      const g = document.getElementById('validMoves');
      if (!g) return;
      g.innerHTML = '';
      for (const m of state.validMoves) {
        const dot = document.createElementNS(NS, 'circle');
        dot.setAttribute('cx', m.to[1] * BASE_SQUARE + BASE_SQUARE / 2);
        dot.setAttribute('cy', m.to[0] * BASE_SQUARE + BASE_SQUARE / 2);
        dot.setAttribute('r', 12);
        dot.setAttribute('class', 'valid-move');
        dot.addEventListener('click', () => {
          applyMove(m);
        });
        g.appendChild(dot);
      }
    }

    function genMoves(r, c) {
      const p = state.board[r][c];
      if (!p) return [];
      const white = p === p.toLowerCase();
      const type = p.toLowerCase();
      const ms = [];

      const add = (rr, cc) => {
        if (rr < 0 || rr > 7 || cc < 0 || cc > 7) return;
        const t = state.board[rr][cc];
        if (!t || (white && t === t.toUpperCase()) || (!white && t === t.toLowerCase())) {
          ms.push({ from: [r, c], to: [rr, cc], piece: p });
        }
      };

      if (type === 'p') {
        const dir = white ? -1 : 1;
        if (!state.board[r + dir]?.[c]) {
          ms.push({ from: [r, c], to: [r + dir, c], piece: p });
        }
        const startRow = white ? 6 : 1;
        if (r === startRow && !state.board[r + dir]?.[c] && !state.board[r + 2 * dir]?.[c]) {
          ms.push({ from: [r, c], to: [r + 2 * dir, c], piece: p });
        }
        [-1, 1].forEach(dc => {
          const rr = r + dir, cc = c + dc;
          if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
            const t = state.board[rr][cc];
            if (t && ((white && t === t.toUpperCase()) || (!white && t === t.toLowerCase()))) {
              ms.push({ from: [r, c], to: [rr, cc], piece: p });
            }
          }
        });
      } else if (type === 'n') {
        [[2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, -2], [2, -1]].forEach(([dr, dc]) => {
          add(r + dr, c + dc);
        });
      } else if (type === 'k') {
        for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
          if (dr || dc) add(r + dr, c + dc);
        }
      } else {
        const dirs = [];
        if (type === 'b' || type === 'q') dirs.push([1, 1], [1, -1], [-1, 1], [-1, -1]);
        if (type === 'r' || type === 'q') dirs.push([1, 0], [-1, 0], [0, 1], [0, -1]);
        for (const [dr, dc] of dirs) {
          let rr = r + dr, cc = c + dc;
          while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
            const t = state.board[rr][cc];
            if (!t) {
              ms.push({ from: [r, c], to: [rr, cc], piece: p });
            } else {
              if ((white && t === t.toUpperCase()) || (!white && t === t.toLowerCase())) {
                ms.push({ from: [r, c], to: [rr, cc], piece: p });
              }
              break;
            }
            rr += dr; cc += dc;
          }
        }
      }
      return ms;
    }

    function applyMove(m) {
      const [fr, fc] = m.from, [tr, tc] = m.to;
      const captured = state.board[tr][tc];
      const piece = state.board[fr][fc];
      state.board[tr][tc] = piece;
      state.board[fr][fc] = null;

      if (!state.firstMoveMade) {
        state.firstMoveMade = true;
        document.getElementById('aiPersonality').disabled = true;
      }

      state.currentPlayer = (state.currentPlayer === 'white' ? 'black' : 'white');
      state.selected = null;
      state.validMoves = [];

      drawPieces();
      showValid();
      pushEdu(explain(piece));

      if (captured && captured.toLowerCase() === 'k') {
        state.gameOver = true;
        document.getElementById('educationalContent').innerHTML = '<div class="insight"><p>GAME OVER</p></div>';
        showReflectionModal();
      } else if (isCheckmate(state.currentPlayer)) {
        state.gameOver = true;
        document.getElementById('educationalContent').innerHTML = '<div class="insight"><p>CHECK MATE</p></div>';
        showReflectionModal();
      } else if (state.currentPlayer === 'black' && !state.gameOver) {
        setTimeout(makeAIMove, 600);
      }
    }

    function getKingPosition(board, isWhite) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = board[r][c];
          if (p && p.toLowerCase() === 'k' && (isWhite ? p === 'k' : p === 'K')) {
            return [r, c];
          }
        }
      }
      return null;
    }

    function isInCheck(board, isWhite) {
      const kingPos = getKingPosition(board, isWhite);
      if (!kingPos) return false;
      const [kr, kc] = kingPos;
      const opponentMoves = getAllMoves(board, !isWhite);
      for (const move of opponentMoves) {
        if (move.to[0] === kr && move.to[1] === kc) {
          return true;
        }
      }
      return false;
    }

    function isCheckmate(isWhite) {
      if (!isInCheck(state.board, isWhite)) return false;
      const moves = getAllMoves(state.board, isWhite);
      for (const move of moves) {
        const newBoard = makeMove(state.board, move);
        if (!isInCheck(newBoard, isWhite)) return false;
      }
      return true;
    }

    function explain(p) {
      const msg = ({
        p: "Artist advancing toward audience.",
        r: "Gatekeeper controlling market access.",
        n: "Legal maneuver creating pathways.",
        b: "Award influence shifting status.",
        q: "Media amplifying reach.",
        k: "Government setting rules."
      })[p.toLowerCase()] || "Move played.";
      return msg;
    }

    function setThinking(msg) {
      document.getElementById('aiThinking').innerHTML = `<p>${msg}</p>`;
    }

    function evaluateBoard(board, persona) {
      const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
      let score = 0;
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p) continue;
        const isWhite = p === p.toLowerCase();
        const value = pieceValues[p.toLowerCase()];
        score += isWhite ? -value : value;
        if (persona.focus === 'control') {
          const center = 4 - (Math.abs(r - 3.5) + Math.abs(c - 3.5));
          score += (isWhite ? -1 : 1) * center * 10;
        }
      }
      if (persona.focus === 'innovation') score += (Math.random() - 0.5) * 50;
      return score;
    }

    function getAllMoves(board, isWhite) {
      const moves = [];
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p || (isWhite && p !== p.toLowerCase()) || (!isWhite && p !== p.toUpperCase())) continue;
        const pieceMoves = genMoves(r, c);
        moves.push(...pieceMoves);
      }
      return moves;
    }

    function makeMove(board, move) {
      const newBoard = board.map(row => [...row]);
      newBoard[move.to[0]][move.to[1]] = newBoard[move.from[0]][move.from[1]];
      newBoard[move.from[0]][move.from[1]] = null;
      return newBoard;
    }

    function minimax(board, depth, alpha, beta, maximizingPlayer, persona) {
      if (depth === 0) return evaluateBoard(board, persona);
      const isWhite = !maximizingPlayer;
      const moves = getAllMoves(board, isWhite);
      if (moves.length === 0) return maximizingPlayer ? -Infinity : Infinity;

      if (maximizingPlayer) {
        let maxEval = -Infinity;
        for (const move of moves) {
          const newBoard = makeMove(board, move);
          const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, persona);
          maxEval = Math.max(maxEval, evaluation);
          alpha = Math.max(alpha, evaluation);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const move of moves) {
          const newBoard = makeMove(board, move);
          const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, persona);
          minEval = Math.min(minEval, evaluation);
          beta = Math.min(beta, evaluation);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function makeAIMove() {
      if (state.aiThinking || state.gameOver || state.currentPlayer !== 'black') return;
      state.aiThinking = true;
      setThinking("AI analyzing industry landscapeâ€¦");

      const persona = aiPersonalities[document.getElementById('aiPersonality').value];
      const moves = getAllMoves(state.board, false);
      if (!moves.length) {
        state.aiThinking = false;
        setThinking("No moves available.");
        return;
      }

      let bestMove = null;
      let bestScore = -Infinity;
      for (const move of moves) {
        const newBoard = makeMove(state.board, move);
        const score = minimax(newBoard, persona.depth - 1, -Infinity, Infinity, false, persona);
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }

      if (bestMove) {
        applyMove(bestMove);
        setThinking(`${persona.name}: ${persona.style}. Focus: ${persona.focus}.`);
      } else {
        setThinking("No valid moves found.");
      }
      state.aiThinking = false;
    }

    function resetGame() {
      state.currentPlayer = 'white';
      state.gameOver = false;
      state.firstMoveMade = false;
      document.getElementById('aiPersonality').disabled = false;
      buildBoard();
      setup();
      drawAll();
      setThinking("AI ready.");
      pushEdu("Game started. You control White (Artists).");
    }

    function undoMove() {
      resetGame();
    }

    function pushEdu(msg) {
      const wrap = document.getElementById('educationalContent');
      const d = document.createElement('div');
      d.className = 'insight';
      d.innerHTML = `<p>${msg}</p>`;
      const olds = wrap.querySelectorAll('.insight');
      if (olds.length >= 3) olds[0].remove();
      wrap.appendChild(d);
      wrap.scrollTop = wrap.scrollHeight;
    }

    // ===== COMMENT SYSTEM FUNCTIONS =====

  async function submitComment() {
  const username = document.getElementById('commentUsername').value || 'Anonymous Strategist';
  const commentText = document.getElementById('commentText').value;

  if (!commentText.trim()) {
    alert('Please enter your insight before sharing.');
    return;
  }

  const isPublic = document.getElementById('commentPublic').checked;

  const payload = {
    Username: username,
    Insight: commentText,
    Public: isPublic
  };

  try {
    const res = await fetch("https://eof9pddhyox83xd.m.pipedream.net", {
      method: "POST",
      body: JSON.stringify(payload),
      headers: {
        "Content-Type": "application/json"
      }
    });

    if (!res.ok) throw new Error("Submission failed");

    document.getElementById('commentText').value = '';
    loadComments(); // refresh
    pushEdu('Thank you for sharing your insight!');
  } catch (err) {
    alert("Failed to submit comment.");
    console.error(err);
  }
}

async function loadComments() {
  try {
    const response = await fetch("https://eot6xk0ora4yj7.m.pipedream.net"); // <-- your GET endpoint
    if (!response.ok) throw new Error("Failed to fetch comments");

    const comments = await response.json();
    displayComments(comments);
  } catch (error) {
    console.error("Error loading comments:", error);
  }
}

setInterval(loadComments, 15000); // Refresh comments every 15s


function displayComments(comments) {
  const container = document.getElementById('commentsList');
  if (!Array.isArray(comments)) {
    container.innerHTML = "<p>No comments yet.</p>";
    return;
  }

  const html = comments.map(c => `
    <div class="comment">
      <div class="comment-username">${c.Username || "Anonymous"}</div>
      <div class="comment-text">${c.Insight}</div>
    </div>
  `).join("");

  container.innerHTML = html;
}


    function formatDate(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
    }

    function showReflectionModal() {
      setTimeout(() => {
        pushEdu("Game ended. Share your insights in the comment section below!");
      }, 1000);
    }

    // Load comments when page loads
    loadComments();
  </script>
</body>
</html>
