<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Industry Chess</title>
  <style>
    body { font-family: Arial, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 2px; background-color: #f0f0f0; }
    #game { display: flex; gap: 10px; }
    #board { border: 2px solid #333; height: 560px; position: relative; }
    #controls { display: flex; flex-direction: column; gap: 5px; height: 560px; }
    #moveList { max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding: 5px; margin: 2px 0; line-height: 1.2; }
    #educationalContent { flex-grow: 1; overflow-y: auto; border: 1px solid #ccc; padding: 5px; margin: 2px 0; line-height: 1.2; }
    .move-item { margin: 2px 0; }
    .insight { margin: 2px 0; }
    .valid-move { fill: rgba(0, 255, 0, 0.5); cursor: pointer; }
    button { padding: 5px; font-size: 14px; cursor: pointer; margin: 2px 0; }
    select { padding: 3px; font-size: 14px; margin: 2px 0; }
    image { pointer-events: auto; }
    #imageErrors { display: none; }
    .legend { font-size: 12px; margin: 2px 0; }
    .popup-image {
      position: absolute;
      width: 210px; /* 3x the original 70px square width minus padding */
      height: 210px; /* 3x the original 70px square height minus padding */
      z-index: 10;
      pointer-events: none;
      display: none;
      border: 2px solid #333;
      background-color: rgba(240, 240, 240, 0.9);
    }
  </style>
</head>
<body>
  <div id="game">
    <svg id="board" width="560" height="560">
      <g id="boardSquares"></g>
      <g id="pieces"></g>
      <g id="popupLayer"></g> <!-- Layer for pop-ups -->
      <g id="validMoves"></g> <!-- Moved to be last for z-index priority -->
    </svg>
    <div id="controls">
      <button id="newBtn">New Game</button>
      <!-- <button id="undoBtn">Undo Move</button> -->
      <!-- <button id="aiBtn">AI Move</button> -->
      <select id="aiPersonality">
        <option value="major">Major Label</option>
        <option value="tech">Tech Platform</option>
      </select>
      <div id="aiThinking"></div>
      <div id="moveList"></div>
      <div id="educationalContent"></div>
      <div id="imageErrors"></div>
    </div>
  </div>
  <script>
    // Quality Check Summary:
    // - Overall: Implements a chess game with music industry theme, including stalemate, en passant, castling, and pawn promotion.
    // - Update: Modified spriteFor and drawPieces to load white piece images using 'white-' prefix (e.g., white-pawn.png) and display white images in pop-ups for white pieces. Removed fallback to black images with whiteAuto filter.
    // - Previous Updates: Added en passant, castling, pawn promotion (auto to queen); removed sound effects.
    // - Strengths: SVG-based board, basic AI with minimax, themed educational content, stalemate detection, special moves.
    // - Issues/Bugs: 
    //   - Undo functionality (resets game) is inaccessible but could be improved to undo single moves.
    //   - No user choice for pawn promotion (auto queen).
    //   - Many console.log statements for debugging; should be conditional on DEBUG flag.
    // - Improvements: Add promotion choice UI, proper undo with history, conditionalize console logs.

    const NS = "http://www.w3.org/2000/svg";
    const SQUARE = 70;
    const ASSET_DIR = "https://pmtwgr.github.io/The-Game/image/";
    const V = "?v=11";
    const DEBUG = true;

    function spriteFor(pieceChar, isBlack = false) {
      const isWhite = (pieceChar === pieceChar.toLowerCase());
      const color = isBlack ? "black-" : (isWhite ? "white-" : "black-");
      const typeMap = { p: "pawn", r: "rook", n: "knight", b: "bishop", q: "queen", k: "king" };
      const type = typeMap[pieceChar.toLowerCase()];
      const sprite = ASSET_DIR + color + type + ".png" + V;
      return sprite;
    }

    const state = {
      board: [],
      currentPlayer: 'white',
      selected: null,
      validMoves: [],
      history: [],
      aiThinking: false,
      gameOver: false,
      firstMoveMade: false,
      castlingRights: {
        white: { kingside: true, queenside: true },
        black: { kingside: true, queenside: true }
      },
      enPassantTarget: null
    };

    const aiPersonalities = {
      major: { name: "Major Label", style: "Market consolidation", risk: 0.55, focus: "control", depth: 3 },
      tech: { name: "Tech Platform", style: "Industry disruption", risk: 0.75, focus: "innovation", depth: 2 }
    };

    window.addEventListener('load', () => {
      document.getElementById('newBtn').onclick = resetGame;
      document.getElementById('aiPersonality').addEventListener('change', () => {
        const persona = aiPersonalities[document.getElementById('aiPersonality').value];
        setThinking(`${persona.name}: ${persona.style}. Focus: ${persona.focus}.`);
      });
      init();
    });

    function init() {
      buildBoard();
      setup();
      state.castlingRights = {
        white: { kingside: true, queenside: true },
        black: { kingside: true, queenside: true }
      };
      state.enPassantTarget = null;
      drawAll();
      pushEdu("Game started. You control White (Artists).");
      const initialPersona = aiPersonalities[document.getElementById('aiPersonality').value];
      setThinking(`${initialPersona.name}: ${initialPersona.style}. Focus: ${initialPersona.focus}.`);
    }

    function buildBoard() {
      const g = document.getElementById('boardSquares');
      g.innerHTML = '';
      state.board = Array.from({ length: 8 }, () => Array(8).fill(null));
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const sq = document.createElementNS(NS, 'rect');
          sq.setAttribute('x', c * SQUARE);
          sq.setAttribute('y', r * SQUARE);
          sq.setAttribute('width', SQUARE);
          sq.setAttribute('height', SQUARE);
          sq.setAttribute('fill', (r + c) % 2 === 0 ? '#fff' : '#eee');
          sq.setAttribute('stroke', '#000');
          sq.addEventListener('click', (e) => {
            onSquare(r, c);
          });
          g.appendChild(sq);
        }
      }
    }

    function setup() {
      placeRow(0, 'black', ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']);
      placeRow(1, 'black', Array(8).fill('p'));
      placeRow(6, 'white', Array(8).fill('p'));
      placeRow(7, 'white', ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r']);
    }

    function placeRow(row, color, arr) {
      for (let c = 0; c < 8; c++) {
        state.board[row][c] = (color === 'white') ? arr[c] : arr[c].toUpperCase();
      }
    }

    function squareToAlgebraic(r, c) {
      return `${String.fromCharCode(97 + c)}${8 - r}`;
    }

    function drawAll() {
      drawPieces();
      showValid();
      updateMoveList();
    }

    function drawPieces() {
      const g = document.getElementById('pieces');
      const popupLayer = document.getElementById('popupLayer');
      popupLayer.innerHTML = '';
      g.innerHTML = '';
      const errorDiv = document.getElementById('imageErrors');
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = state.board[r][c];
          if (!p) continue;
          const img = document.createElementNS(NS, 'image');
          const src = spriteFor(p);
          img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);
          img.setAttribute('href', src);
          img.setAttribute('x', c * SQUARE + 5);
          img.setAttribute('y', r * SQUARE + 5);
          img.setAttribute('width', SQUARE - 10);
          img.setAttribute('height', SQUARE - 10);
          if (p === p.toLowerCase()) {
            img.addEventListener('error', () => {
              errorDiv.innerHTML += `<p>Error loading image for ${p} at ${squareToAlgebraic(r, c)}: ${src}</p>`;
            }, { once: true });
            img.addEventListener('mouseover', () => {
              const popup = document.createElementNS(NS, 'image');
              const type = p.toLowerCase();
              const popupSrc = spriteFor(type, false); // Use white image for white pieces
              popup.setAttributeNS('http://www.w3.org/1999/xlink', 'href', popupSrc);
              popup.setAttribute('href', popupSrc);
              popup.setAttribute('class', 'popup-image');
              popup.setAttribute('x', c * SQUARE - 70);
              popup.setAttribute('y', r * SQUARE - 215);
              popup.setAttribute('width', 210);
              popup.setAttribute('height', 210);
              popup.style.display = 'inline';
              popupLayer.appendChild(popup);
            });
            img.addEventListener('mouseout', () => {
              popupLayer.innerHTML = '';
            });
            img.addEventListener('click', (e) => {
              e.stopPropagation();
              onSquare(r, c);
            });
          } else {
            img.addEventListener('click', (e) => {
              e.stopPropagation();
              onSquare(r, c);
            });
          }
          g.appendChild(img);
        }
      }
    }

    function onSquare(r, c) {
      if (state.aiThinking || state.gameOver) {
        return;
      }
      const piece = state.board[r][c];
      
      if (state.selected) {
        const [sr, sc] = state.selected;
        const mv = state.validMoves.find(m => m.to[0] === r && m.to[1] === c);
        if (mv) {
          applyMove(mv);
          return;
        }
        state.selected = null;
        state.validMoves = [];
        showValid();
      }

      if (piece) {
        const isWhite = piece === piece.toLowerCase();
        if ((state.currentPlayer === 'white' && isWhite) || (state.currentPlayer === 'black' && !isWhite)) {
          state.selected = [r, c];
          state.validMoves = getLegalMoves(state.board, r, c, state.enPassantTarget, state.castlingRights, state.currentPlayer === 'white');
          showValid();
        }
      }
    }

    function showValid() {
      const g = document.getElementById('validMoves');
      if (!g) return;
      g.innerHTML = '';
      for (const m of state.validMoves) {
        const dot = document.createElementNS(NS, 'circle');
        dot.setAttribute('cx', m.to[1] * SQUARE + SQUARE / 2);
        dot.setAttribute('cy', m.to[0] * SQUARE + SQUARE / 2);
        dot.setAttribute('r', 12);
        dot.setAttribute('class', 'valid-move');
        dot.addEventListener('click', () => {
          applyMove(m);
        });
        g.appendChild(dot);
      }
    }

    function genPseudoLegalMoves(board, r, c, enPassantTarget, castlingRights) {
      const p = board[r][c];
      if (!p) return [];
      const white = p === p.toLowerCase();
      const type = p.toLowerCase();
      const ms = [];

      const add = (rr, cc, special = null) => {
        if (rr < 0 || rr > 7 || cc < 0 || cc > 7) return;
        const t = board[rr][cc];
        if (!t || (white && t === t.toUpperCase()) || (!white && t === t.toLowerCase())) {
          const m = { from: [r, c], to: [rr, cc], piece: p };
          if (special === 'enPassant') m.enPassant = true;
          if (special === 'castlingKingside') m.castling = 'kingside';
          if (special === 'castlingQueenside') m.castling = 'queenside';
          ms.push(m);
        }
      };

      if (type === 'p') {
        const dir = white ? -1 : 1;
        const forward = r + dir;
        if (forward >= 0 && forward < 8 && !board[forward][c]) {
          add(forward, c);
        }
        const startRow = white ? 6 : 1;
        const double = r + 2 * dir;
        if (r === startRow && forward >= 0 && double >= 0 && forward < 8 && double < 8 && !board[forward][c] && !board[double][c]) {
          add(double, c);
        }
        [-1, 1].forEach(dc => {
          const rr = r + dir, cc = c + dc;
          if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
            const t = board[rr][cc];
            if (t && ((white && t === t.toUpperCase()) || (!white && t === t.toLowerCase()))) {
              add(rr, cc);
            }
          }
        });
        const epRow = white ? 2 : 5;
        if (enPassantTarget && r === (white ? 3 : 4) && Math.abs(c - enPassantTarget[1]) === 1 && enPassantTarget[0] === epRow) {
          add(enPassantTarget[0], enPassantTarget[1], 'enPassant');
        }
      } else if (type === 'n') {
        [[2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, -2], [2, -1]].forEach(([dr, dc]) => {
          add(r + dr, c + dc);
        });
      } else if (type === 'k') {
        for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
          if (dr || dc) add(r + dr, c + dc);
        }
        const homeRow = white ? 7 : 0;
        if (r === homeRow && c === 4) {
          const color = white ? 'white' : 'black';
          if (castlingRights[color].kingside && !isInCheck(board, white) && !isSquareAttacked(board, homeRow, 5, !white) && !isSquareAttacked(board, homeRow, 6, !white) && !board[homeRow][5] && !board[homeRow][6]) {
            add(homeRow, 6, 'castlingKingside');
          }
          if (castlingRights[color].queenside && !isInCheck(board, white) && !isSquareAttacked(board, homeRow, 3, !white) && !isSquareAttacked(board, homeRow, 2, !white) && !board[homeRow][1] && !board[homeRow][2] && !board[homeRow][3]) {
            add(homeRow, 2, 'castlingQueenside');
          }
        }
      } else {
        const dirs = [];
        if (type === 'b' || type === 'q') dirs.push([1, 1], [1, -1], [-1, 1], [-1, -1]);
        if (type === 'r' || type === 'q') dirs.push([1, 0], [-1, 0], [0, 1], [0, -1]);
        for (const [dr, dc] of dirs) {
          let rr = r + dr, cc = c + dc;
          while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
            const t = board[rr][cc];
            add(rr, cc);
            if (t) break;
            rr += dr; cc += dc;
          }
        }
      }
      return ms;
    }

    function getLegalMoves(board, r, c, enPassantTarget, castlingRights, isWhite) {
      const potential = genPseudoLegalMoves(board, r, c, enPassantTarget, castlingRights);
      return potential.filter(m => {
        const {newBoard} = applyMoveToBoard(board, m);
        return !isInCheck(newBoard, isWhite);
      });
    }

    function getAllPseudoLegalMoves(board, isWhite, enPassantTarget, castlingRights) {
      const moves = [];
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p || (isWhite && p !== p.toLowerCase()) || (!isWhite && p !== p.toUpperCase())) continue;
        const pieceMoves = genPseudoLegalMoves(board, r, c, enPassantTarget, castlingRights);
        moves.push(...pieceMoves);
      }
      return moves;
    }

    function getAllLegalMoves(board, isWhite, enPassantTarget, castlingRights) {
      const moves = [];
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p || (isWhite && p !== p.toLowerCase()) || (!isWhite && p !== p.toUpperCase())) continue;
        const pieceMoves = getLegalMoves(board, r, c, enPassantTarget, castlingRights, isWhite);
        moves.push(...pieceMoves);
      }
      return moves;
    }

    function applyMoveToBoard(board, m) {
      const newBoard = board.map(row => [...row]);
      const [fr, fc] = m.from, [tr, tc] = m.to;
      const piece = newBoard[fr][fc];
      newBoard[tr][tc] = piece;
      newBoard[fr][fc] = null;
      let newEnPassantTarget = null;
      const newCastlingRights = JSON.parse(JSON.stringify(state.castlingRights));

      const white = piece === piece.toLowerCase();
      const color = white ? 'white' : 'black';
      const opponentColor = white ? 'black' : 'white';
      const homeRow = white ? 7 : 0;
      const opponentHomeRow = white ? 0 : 7;

      if (m.enPassant) {
        const dir = white ? -1 : 1;
        const capturedRow = tr - dir;
        newBoard[capturedRow][tc] = null;
      }

      if (m.castling) {
        if (m.castling === 'kingside') {
          newBoard[homeRow][5] = newBoard[homeRow][7];
          newBoard[homeRow][7] = null;
        } else {
          newBoard[homeRow][3] = newBoard[homeRow][0];
          newBoard[homeRow][0] = null;
        }
      }

      const endRow = white ? 0 : 7;
      if (piece.toLowerCase() === 'p' && tr === endRow) {
        newBoard[tr][tc] = white ? 'q' : 'Q';
      }

      if (piece.toLowerCase() === 'p' && Math.abs(fr - tr) === 2) {
        const epRow = (fr + tr) / 2;
        newEnPassantTarget = [epRow, fc];
      }

      if (piece.toLowerCase() === 'k') {
        newCastlingRights[color].kingside = false;
        newCastlingRights[color].queenside = false;
      } else if (piece.toLowerCase() === 'r') {
        if (fr === homeRow) {
          if (fc === 7) newCastlingRights[color].kingside = false;
          if (fc === 0) newCastlingRights[color].queenside = false;
        }
      }

      const captured = board[tr][tc] ? board[tr][tc] : null;
      if (captured && captured.toLowerCase() === 'r') {
        if (tr === opponentHomeRow) {
          if (tc === 7) newCastlingRights[opponentColor].kingside = false;
          if (tc === 0) newCastlingRights[opponentColor].queenside = false;
        }
      }

      return { newBoard, newEnPassantTarget, newCastlingRights };
    }

    function applyMove(m) {
      const isWhite = state.currentPlayer === 'white';
      const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(state.board, m);
      state.board = newBoard;
      state.enPassantTarget = newEnPassantTarget;
      state.castlingRights = newCastlingRights;

      const alg = squareToAlgebraic(m.from[0], m.from[1]) + '-' + squareToAlgebraic(m.to[0], m.to[1]);
      state.history.push(alg);
      updateMoveList();

      if (!state.firstMoveMade) {
        state.firstMoveMade = true;
        document.getElementById('aiPersonality').disabled = true;
      }

      state.currentPlayer = (state.currentPlayer === 'white' ? 'black' : 'white');
      state.selected = null;
      state.validMoves = [];

      drawPieces();
      showValid();
      pushEdu(explain(m.piece));

      const captured = state.board[m.to[0]][m.to[1]] !== m.piece ? state.board[m.to[0]][m.to[1]] : null;
      if (captured && captured.toLowerCase() === 'k') {
        state.gameOver = true;
        document.getElementById('educationalContent').innerHTML = '<div class="insight"><p>GAME OVER</p></div>';
      } else {
        const gameEndStatus = checkGameEnd(state.currentPlayer === 'white');
        if (gameEndStatus === 'checkmate') {
          state.gameOver = true;
          document.getElementById('educationalContent').innerHTML = '<div class="insight"><p>CHECK MATE</p></div>';
        } else if (gameEndStatus === 'stalemate') {
          state.gameOver = true;
          document.getElementById('educationalContent').innerHTML = '<div class="insight"><p>STALEMATE</p></div>';
        } else if (state.currentPlayer === 'black' && !state.gameOver) {
          setTimeout(makeAIMove, 600);
        }
      }
    }

    function getKingPosition(board, isWhite) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = board[r][c];
          if (p && p.toLowerCase() === 'k' && (isWhite ? p === 'k' : p === 'K')) {
            return [r, c];
          }
        }
      }
      return null;
    }

    function isInCheck(board, isWhite) {
      const kingPos = getKingPosition(board, isWhite);
      if (!kingPos) return false;
      const [kr, kc] = kingPos;
      const opponentMoves = getAllPseudoLegalMoves(board, !isWhite, null, null);
      for (const move of opponentMoves) {
        if (move.to[0] === kr && move.to[1] === kc) {
          return true;
        }
      }
      return false;
    }

    function isSquareAttacked(board, row, col, attackerWhite) {
      const dummyBoard = board.map(row => [...row]);
      dummyBoard[row][col] = attackerWhite ? 'p' : 'P';
      const attacks = getAllPseudoLegalMoves(dummyBoard, attackerWhite, null, null);
      return attacks.some(m => m.to[0] === row && m.to[1] === col);
    }

    function checkGameEnd(isWhite) {
      const moves = getAllLegalMoves(state.board, isWhite, state.enPassantTarget, state.castlingRights);
      if (moves.length === 0) {
        if (isInCheck(state.board, isWhite)) {
          return 'checkmate';
        } else {
          return 'stalemate';
        }
      }
      return 'ongoing';
    }

    function explain(p) {
      const msg = ({
        p: "Artist advancing toward audience.",
        r: "Gatekeeper controlling market access.",
        n: "Legal maneuver creating pathways.",
        b: "Award influence shifting status.",
        q: "Media amplifying reach.",
        k: "Government setting rules."
      })[p.toLowerCase()] || "Move played.";
      return msg;
    }

    function updateMoveList() {
      const box = document.getElementById('moveList');
      box.innerHTML = '';
      state.history.forEach((mv, i) => {
        const el = document.createElement('div');
        el.className = 'move-item';
        el.textContent = `${i + 1}. ${mv}`;
        box.appendChild(el);
      });
      box.scrollTop = box.scrollHeight;
    }

    function setThinking(msg) {
      document.getElementById('aiThinking').innerHTML = `<p>${msg}</p>`;
    }

    function evaluateBoard(board, persona) {
      const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
      let score = 0;
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p) continue;
        const isWhite = p === p.toLowerCase();
        const value = pieceValues[p.toLowerCase()];
        score += isWhite ? -value : value;
        if (persona.focus === 'control') {
          const center = 4 - (Math.abs(r - 3.5) + Math.abs(c - 3.5));
          score += (isWhite ? -1 : 1) * center * 10;
        }
      }
      if (persona.focus === 'innovation') score += (Math.random() - 0.5) * 50;
      return score;
    }

    function minimax(board, depth, alpha, beta, maximizingPlayer, persona, enPassantTarget, castlingRights) {
      if (depth === 0) {
        return evaluateBoard(board, persona);
      }
      const isWhite = !maximizingPlayer;
      const pseudoMoves = getAllPseudoLegalMoves(board, isWhite, enPassantTarget, castlingRights);
      const legalMoves = pseudoMoves.filter(m => {
        const {newBoard} = applyMoveToBoard(board, m);
        return !isInCheck(newBoard, isWhite);
      });
      if (legalMoves.length === 0) {
        return maximizingPlayer ? -Infinity : Infinity;
      }

      if (maximizingPlayer) {
        let maxEval = -Infinity;
        for (const move of legalMoves) {
          const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(board, move);
          const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, persona, newEnPassantTarget, newCastlingRights);
          maxEval = Math.max(maxEval, evaluation);
          alpha = Math.max(alpha, evaluation);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const move of legalMoves) {
          const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(board, move);
          const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, persona, newEnPassantTarget, newCastlingRights);
          minEval = Math.min(minEval, evaluation);
          beta = Math.min(beta, evaluation);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function makeAIMove() {
      if (state.aiThinking || state.gameOver || state.currentPlayer !== 'black') {
        return;
      }
      state.aiThinking = true;
      setThinking("AI analyzing industry landscape…");

      const persona = aiPersonalities[document.getElementById('aiPersonality').value];
      const pseudoMoves = getAllPseudoLegalMoves(state.board, false, state.enPassantTarget, state.castlingRights);
      const legalMoves = pseudoMoves.filter(m => {
        const {newBoard} = applyMoveToBoard(state.board, m);
        return !isInCheck(newBoard, false);
      });
      if (!legalMoves.length) {
        state.aiThinking = false;
        setThinking("No moves available.");
        return;
      }

      let bestMove = null;
      let bestScore = -Infinity;
      for (const move of legalMoves) {
        const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(state.board, move);
        const score = minimax(newBoard, persona.depth - 1, -Infinity, Infinity, false, persona, newEnPassantTarget, newCastlingRights);
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }

      if (bestMove) {
        applyMove(bestMove);
        setThinking(`${persona.name}: ${persona.style}. Focus: ${persona.focus}.`);
      } else {
        setThinking("No valid moves found.");
      }
      state.aiThinking = false;
    }

    function resetGame() {
      state.history = [];
      state.currentPlayer = 'white';
      state.gameOver = false;
      state.firstMoveMade = false;
      state.castlingRights = {
        white: { kingside: true, queenside: true },
        black: { kingside: true, queenside: true }
      };
      state.enPassantTarget = null;
      document.getElementById('aiPersonality').disabled = false;
      buildBoard();
      setup();
      drawAll();
      setThinking("AI ready.");
      pushEdu("Game started. You control White (Artists).");
    }

    function undoMove() {
      resetGame();
    }

    function pushEdu(msg) {
      const wrap = document.getElementById('educationalContent');
      const d = document.createElement('div');
      d.className = 'insight';
      d.innerHTML = `<p>${msg}</p>`;
      const olds = wrap.querySelectorAll('.insight');
      if (olds.length >= 3) olds[0].remove();
      wrap.appendChild(d);
      wrap.scrollTop = wrap.scrollHeight;
    }
  </script>
</body>
</html>
