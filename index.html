<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music Industry Chess</title>
  <style>
    * { box-sizing: border-box; }
    body { 
      font-family: Arial, sans-serif; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      margin: 0; 
      padding: 20px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    #game { 
      display: flex; 
      gap: 20px; 
      flex-wrap: wrap; 
      justify-content: center;
      max-width: 1200px;
    }
    #board { 
      border: 4px solid #333; 
      box-shadow: 0 8px 16px rgba(0,0,0,0.3);
      background: white;
    }
    #controls { 
      display: flex; 
      flex-direction: column; 
      gap: 10px; 
      width: 280px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
    h3 {
      margin: 0 0 10px 0;
      color: #333;
      font-size: 18px;
    }
    #moveList { 
      max-height: 150px; 
      overflow-y: auto; 
      border: 1px solid #ddd; 
      padding: 8px; 
      background: #fafafa; 
      border-radius: 4px; 
      font-size: 13px;
      font-family: monospace;
    }
    #educationalContent { 
      flex-grow: 1; 
      overflow-y: auto; 
      border: 1px solid #ddd; 
      padding: 10px; 
      background: #fafafa; 
      border-radius: 4px; 
      font-size: 13px; 
      min-height: 180px;
      line-height: 1.5;
    }
    .move-item { 
      margin: 3px 0; 
      padding: 3px 5px;
      background: white;
      border-radius: 2px;
    }
    .insight { 
      margin: 8px 0; 
      padding: 8px; 
      background: white; 
      border-left: 4px solid #667eea;
      border-radius: 3px;
    }
    .valid-move { 
      fill: rgba(76, 175, 80, 0.7); 
      cursor: pointer; 
      stroke: #2E7D32; 
      stroke-width: 2;
    }
    .valid-move:hover { 
      fill: rgba(76, 175, 80, 0.9);
      transform: scale(1.1);
    }
    .selected-square { 
      fill: rgba(255, 235, 59, 0.5);
      stroke: #FBC02D;
      stroke-width: 3;
    }
    button { 
      padding: 12px; 
      font-size: 14px; 
      font-weight: 600;
      cursor: pointer; 
      background: #667eea; 
      color: white; 
      border: none; 
      border-radius: 6px; 
      transition: all 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    button:hover { 
      background: #5568d3;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
    button:active {
      transform: translateY(0);
    }
    button:disabled { 
      background: #ccc; 
      cursor: not-allowed;
      transform: none;
    }
    select { 
      padding: 10px; 
      font-size: 14px; 
      border: 2px solid #ddd; 
      border-radius: 6px;
      background: white;
      cursor: pointer;
      transition: border 0.3s;
    }
    select:focus {
      outline: none;
      border-color: #667eea;
    }
    #aiThinking { 
      padding: 10px; 
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 6px; 
      font-size: 13px; 
      min-height: 45px; 
      display: flex; 
      align-items: center;
      justify-content: center;
      font-weight: 500;
      text-align: center;
    }
    .piece { 
      cursor: pointer; 
      transition: transform 0.15s ease;
    }
    .piece:hover { 
      transform: scale(1.15);
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.3));
    }
    .popup-image { 
      position: absolute; 
      width: 210px; 
      height: 210px; 
      z-index: 1000; 
      pointer-events: none; 
      display: none; 
      border: 4px solid #667eea; 
      background: white; 
      box-shadow: 0 8px 24px rgba(0,0,0,0.4); 
      border-radius: 8px;
      padding: 10px;
    }
    .status-bar {
      padding: 8px;
      background: #f0f0f0;
      border-radius: 4px;
      font-size: 12px;
      text-align: center;
      color: #666;
      font-weight: 500;
    }
    @media (max-width: 768px) {
      #game { flex-direction: column; align-items: center; }
      #controls { width: 100%; max-width: 560px; }
    }
  </style>
</head>
<body>
  <div id="game">
    <svg id="board" width="560" height="560">
      <defs>
        <filter id="shadow">
          <feDropShadow dx="2" dy="2" stdDeviation="3" flood-opacity="0.4"/>
        </filter>
      </defs>
      <g id="boardSquares"></g>
      <g id="highlightLayer"></g>
      <g id="validMoves"></g>
      <g id="pieces"></g>
      <g id="popupLayer"></g>
    </svg>
    <div id="controls">
      <h3>üéµ Music Industry Chess</h3>
      <button id="newBtn">üîÑ New Game</button>
      <select id="aiPersonality">
        <option value="major">üè¢ Major Label</option>
        <option value="tech">üíª Tech Platform</option>
      </select>
      <div class="status-bar" id="statusBar">White to move</div>
      <div id="aiThinking">AI ready</div>
      <div>
        <h3>Move History</h3>
        <div id="moveList"></div>
      </div>
      <div>
        <h3>Game Insights</h3>
        <div id="educationalContent"></div>
      </div>
    </div>
  </div>
  <script>
    const NS = "http://www.w3.org/2000/svg";
    const SQUARE = 70;
    const ASSET_DIR = "https://pmtwgr.github.io/The-Game/image/";
    const V = "?v=20250201";

    function spriteFor(pieceChar) {
      const isWhite = (pieceChar === pieceChar.toLowerCase());
      const color = isWhite ? "white-" : "black-";
      const typeMap = { p: "pawn", r: "rook", n: "knight", b: "bishop", q: "queen", k: "king" };
      const type = typeMap[pieceChar.toLowerCase()];
      return ASSET_DIR + color + type + ".png" + V;
    }

    const state = {
      board: [],
      currentPlayer: 'white',
      selected: null,
      validMoves: [],
      history: [],
      aiThinking: false,
      gameOver: false,
      firstMoveMade: false,
      castlingRights: { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } },
      enPassantTarget: null
    };

    const aiPersonalities = {
      major: { name: "Major Label", style: "Market consolidation", focus: "control", depth: 3 },
      tech: { name: "Tech Platform", style: "Industry disruption", focus: "innovation", depth: 2 }
    };

    window.addEventListener('load', () => {
      document.getElementById('newBtn').onclick = resetGame;
      document.getElementById('aiPersonality').addEventListener('change', updateAIStatus);
      init();
    });

    function init() {
      buildBoard();
      setupPieces();
      state.castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
      state.enPassantTarget = null;
      state.currentPlayer = 'white';
      state.selected = null;
      state.validMoves = [];
      state.history = [];
      state.gameOver = false;
      state.firstMoveMade = false;
      state.aiThinking = false;
      drawAll();
      pushEdu("Game started. You control White (Artists). Click a piece to select it.");
      updateAIStatus();
      updateStatusBar();
    }

    function buildBoard() {
      const g = document.getElementById('boardSquares');
      g.innerHTML = '';
      state.board = Array.from({ length: 8 }, () => Array(8).fill(null));
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const sq = document.createElementNS(NS, 'rect');
          sq.setAttribute('x', c * SQUARE);
          sq.setAttribute('y', r * SQUARE);
          sq.setAttribute('width', SQUARE);
          sq.setAttribute('height', SQUARE);
          sq.setAttribute('fill', (r + c) % 2 === 0 ? '#ffffff' : '#000000');
          sq.setAttribute('stroke', 'none');
          sq.setAttribute('data-row', r);
          sq.setAttribute('data-col', c);
          sq.style.cursor = 'pointer';
          sq.addEventListener('click', () => handleSquareClick(r, c));
          g.appendChild(sq);
        }
      }
    }

    function setupPieces() {
      const backRow = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];
      for (let c = 0; c < 8; c++) {
        state.board[0][c] = backRow[c].toUpperCase();
        state.board[1][c] = 'P';
        state.board[6][c] = 'p';
        state.board[7][c] = backRow[c];
      }
    }

    function drawAll() {
      drawHighlight();
      drawPieces();
      showValidMoves();
      updateMoveList();
      updateStatusBar();
    }

    function drawHighlight() {
      const g = document.getElementById('highlightLayer');
      g.innerHTML = '';
      if (state.selected) {
        const [r, c] = state.selected;
        const hl = document.createElementNS(NS, 'rect');
        hl.setAttribute('x', c * SQUARE);
        hl.setAttribute('y', r * SQUARE);
        hl.setAttribute('width', SQUARE);
        hl.setAttribute('height', SQUARE);
        hl.setAttribute('class', 'selected-square');
        hl.setAttribute('pointer-events', 'none');
        g.appendChild(hl);
      }
    }

    function drawPieces() {
      const g = document.getElementById('pieces');
      const popupLayer = document.getElementById('popupLayer');
      g.innerHTML = '';
      popupLayer.innerHTML = '';

      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = state.board[r][c];
          if (!p) continue;

          const img = document.createElementNS(NS, 'image');
          const src = spriteFor(p);
          img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);
          img.setAttribute('href', src);
          img.setAttribute('x', c * SQUARE + 5);
          img.setAttribute('y', r * SQUARE + 5);
          img.setAttribute('width', SQUARE - 10);
          img.setAttribute('height', SQUARE - 10);
          img.setAttribute('class', 'piece');
          img.setAttribute('data-row', r);
          img.setAttribute('data-col', c);
          
          img.addEventListener('error', function(e) {
            console.error('Failed to load image:', src);
          });
          
          img.addEventListener('click', (e) => {
            e.stopPropagation();
            handleSquareClick(r, c);
          });

          if (p === p.toLowerCase()) {
            img.addEventListener('mouseenter', () => showPopup(r, c, p));
            img.addEventListener('mouseleave', hidePopup);
          }

          g.appendChild(img);
        }
      }
    }

    function showPopup(r, c, piece) {
      const popupLayer = document.getElementById('popupLayer');
      popupLayer.innerHTML = '';
      
      const popup = document.createElementNS(NS, 'image');
      const src = spriteFor(piece);
      popup.setAttributeNS('http://www.w3.org/1999/xlink', 'href', src);
      popup.setAttribute('href', src);
      popup.setAttribute('class', 'popup-image');
      
      let x = c * SQUARE - 70;
      let y = r * SQUARE - 215;
      
      if (x < 0) x = c * SQUARE + SQUARE + 5;
      if (y < 0) y = r * SQUARE + SQUARE + 5;
      
      popup.setAttribute('x', x);
      popup.setAttribute('y', y);
      popup.setAttribute('width', 210);
      popup.setAttribute('height', 210);
      popup.style.display = 'block';
      
      popupLayer.appendChild(popup);
    }

    function hidePopup() {
      const popupLayer = document.getElementById('popupLayer');
      popupLayer.innerHTML = '';
    }

    function handleSquareClick(r, c) {
      if (state.aiThinking || state.gameOver) return;

      const piece = state.board[r][c];
      const isWhite = piece && piece === piece.toLowerCase();
      const isPlayerPiece = piece && ((state.currentPlayer === 'white' && isWhite) || (state.currentPlayer === 'black' && !isWhite));

      if (state.selected) {
        const validMove = state.validMoves.find(m => m.to[0] === r && m.to[1] === c);
        
        if (validMove) {
          applyMove(validMove);
          return;
        }
        
        if (isPlayerPiece) {
          state.selected = [r, c];
          state.validMoves = getLegalMoves(state.board, r, c, state.enPassantTarget, state.castlingRights, state.currentPlayer === 'white');
          drawAll();
          return;
        }
        
        state.selected = null;
        state.validMoves = [];
        drawAll();
        return;
      }

      if (isPlayerPiece) {
        state.selected = [r, c];
        state.validMoves = getLegalMoves(state.board, r, c, state.enPassantTarget, state.castlingRights, state.currentPlayer === 'white');
        drawAll();
      }
    }

    function showValidMoves() {
      const g = document.getElementById('validMoves');
      g.innerHTML = '';
      
      for (const m of state.validMoves) {
        const circle = document.createElementNS(NS, 'circle');
        circle.setAttribute('cx', m.to[1] * SQUARE + SQUARE / 2);
        circle.setAttribute('cy', m.to[0] * SQUARE + SQUARE / 2);
        circle.setAttribute('r', 15);
        circle.setAttribute('class', 'valid-move');
        circle.addEventListener('click', (e) => {
          e.stopPropagation();
          applyMove(m);
        });
        g.appendChild(circle);
      }
    }

    function genPseudoLegalMoves(board, r, c, enPassantTarget, castlingRights) {
      const p = board[r][c];
      if (!p) return [];
      const white = p === p.toLowerCase();
      const type = p.toLowerCase();
      const ms = [];

      const add = (rr, cc, special = null) => {
        if (rr < 0 || rr > 7 || cc < 0 || cc > 7) return;
        const t = board[rr][cc];
        if (!t || (white && t === t.toUpperCase()) || (!white && t === t.toLowerCase())) {
          const m = { from: [r, c], to: [rr, cc], piece: p };
          if (special === 'enPassant') m.enPassant = true;
          if (special === 'castlingKingside') m.castling = 'kingside';
          if (special === 'castlingQueenside') m.castling = 'queenside';
          ms.push(m);
        }
      };

      if (type === 'p') {
        const dir = white ? -1 : 1;
        const forward = r + dir;
        if (forward >= 0 && forward < 8 && !board[forward][c]) {
          add(forward, c);
        }
        const startRow = white ? 6 : 1;
        const double = r + 2 * dir;
        if (r === startRow && forward >= 0 && double >= 0 && forward < 8 && double < 8 && !board[forward][c] && !board[double][c]) {
          add(double, c);
        }
        [-1, 1].forEach(dc => {
          const rr = r + dir, cc = c + dc;
          if (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
            const t = board[rr][cc];
            if (t && ((white && t === t.toUpperCase()) || (!white && t === t.toLowerCase()))) {
              add(rr, cc);
            }
          }
        });
        const epRow = white ? 2 : 5;
        if (enPassantTarget && r === (white ? 3 : 4) && Math.abs(c - enPassantTarget[1]) === 1 && enPassantTarget[0] === epRow) {
          add(enPassantTarget[0], enPassantTarget[1], 'enPassant');
        }
      } else if (type === 'n') {
        [[2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1], [-1, -2], [1, -2], [2, -1]].forEach(([dr, dc]) => {
          add(r + dr, c + dc);
        });
      } else if (type === 'k') {
        for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
          if (dr || dc) add(r + dr, c + dc);
        }
        const homeRow = white ? 7 : 0;
        if (r === homeRow && c === 4) {
          const color = white ? 'white' : 'black';
          if (castlingRights[color].kingside && !isInCheck(board, white) && !isSquareAttacked(board, homeRow, 5, !white) && !isSquareAttacked(board, homeRow, 6, !white) && !board[homeRow][5] && !board[homeRow][6]) {
            add(homeRow, 6, 'castlingKingside');
          }
          if (castlingRights[color].queenside && !isInCheck(board, white) && !isSquareAttacked(board, homeRow, 3, !white) && !isSquareAttacked(board, homeRow, 2, !white) && !board[homeRow][1] && !board[homeRow][2] && !board[homeRow][3]) {
            add(homeRow, 2, 'castlingQueenside');
          }
        }
      } else {
        const dirs = [];
        if (type === 'b' || type === 'q') dirs.push([1, 1], [1, -1], [-1, 1], [-1, -1]);
        if (type === 'r' || type === 'q') dirs.push([1, 0], [-1, 0], [0, 1], [0, -1]);
        for (const [dr, dc] of dirs) {
          let rr = r + dr, cc = c + dc;
          while (rr >= 0 && rr < 8 && cc >= 0 && cc < 8) {
            const t = board[rr][cc];
            add(rr, cc);
            if (t) break;
            rr += dr; cc += dc;
          }
        }
      }
      return ms;
    }

    function getLegalMoves(board, r, c, enPassantTarget, castlingRights, isWhite) {
      const potential = genPseudoLegalMoves(board, r, c, enPassantTarget, castlingRights);
      return potential.filter(m => {
        const {newBoard} = applyMoveToBoard(board, m);
        return !isInCheck(newBoard, isWhite);
      });
    }

    function getAllPseudoLegalMoves(board, isWhite, enPassantTarget, castlingRights) {
      const moves = [];
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p || (isWhite && p !== p.toLowerCase()) || (!isWhite && p !== p.toUpperCase())) continue;
        moves.push(...genPseudoLegalMoves(board, r, c, enPassantTarget, castlingRights));
      }
      return moves;
    }

    function getAllLegalMoves(board, isWhite, enPassantTarget, castlingRights) {
      const moves = [];
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p || (isWhite && p !== p.toLowerCase()) || (!isWhite && p !== p.toUpperCase())) continue;
        moves.push(...getLegalMoves(board, r, c, enPassantTarget, castlingRights, isWhite));
      }
      return moves;
    }

    function applyMoveToBoard(board, m) {
      const newBoard = board.map(row => [...row]);
      const [fr, fc] = m.from, [tr, tc] = m.to;
      const piece = newBoard[fr][fc];
      newBoard[tr][tc] = piece;
      newBoard[fr][fc] = null;
      let newEnPassantTarget = null;
      const newCastlingRights = JSON.parse(JSON.stringify(state.castlingRights));

      const white = piece === piece.toLowerCase();
      const color = white ? 'white' : 'black';
      const opponentColor = white ? 'black' : 'white';
      const homeRow = white ? 7 : 0;
      const opponentHomeRow = white ? 0 : 7;

      if (m.enPassant) {
        const dir = white ? -1 : 1;
        newBoard[tr - dir][tc] = null;
      }

      if (m.castling) {
        if (m.castling === 'kingside') {
          newBoard[homeRow][5] = newBoard[homeRow][7];
          newBoard[homeRow][7] = null;
        } else {
          newBoard[homeRow][3] = newBoard[homeRow][0];
          newBoard[homeRow][0] = null;
        }
      }

      const endRow = white ? 0 : 7;
      if (piece.toLowerCase() === 'p' && tr === endRow) {
        newBoard[tr][tc] = white ? 'q' : 'Q';
      }

      if (piece.toLowerCase() === 'p' && Math.abs(fr - tr) === 2) {
        newEnPassantTarget = [(fr + tr) / 2, fc];
      }

      if (piece.toLowerCase() === 'k') {
        newCastlingRights[color].kingside = false;
        newCastlingRights[color].queenside = false;
      } else if (piece.toLowerCase() === 'r') {
        if (fr === homeRow) {
          if (fc === 7) newCastlingRights[color].kingside = false;
          if (fc === 0) newCastlingRights[color].queenside = false;
        }
      }

      const captured = board[tr][tc];
      if (captured && captured.toLowerCase() === 'r') {
        if (tr === opponentHomeRow) {
          if (tc === 7) newCastlingRights[opponentColor].kingside = false;
          if (tc === 0) newCastlingRights[opponentColor].queenside = false;
        }
      }

      return { newBoard, newEnPassantTarget, newCastlingRights };
    }

    function applyMove(m) {
      const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(state.board, m);
      state.board = newBoard;
      state.enPassantTarget = newEnPassantTarget;
      state.castlingRights = newCastlingRights;

      const alg = squareToAlgebraic(m.from[0], m.from[1]) + '-' + squareToAlgebraic(m.to[0], m.to[1]);
      state.history.push(alg);

      if (!state.firstMoveMade) {
        state.firstMoveMade = true;
        document.getElementById('aiPersonality').disabled = true;
      }

      state.currentPlayer = (state.currentPlayer === 'white' ? 'black' : 'white');
      state.selected = null;
      state.validMoves = [];

      drawAll();
      pushEdu(explainMove(m.piece));

      const gameEndStatus = checkGameEnd(state.currentPlayer === 'white');
      if (gameEndStatus === 'checkmate') {
        state.gameOver = true;
        pushEdu("üèÜ CHECKMATE! " + (state.currentPlayer === 'white' ? 'Black wins!' : 'White wins!'));
        updateStatusBar();
      } else if (gameEndStatus === 'stalemate') {
        state.gameOver = true;
        pushEdu("ü§ù STALEMATE! Game is a draw.");
        updateStatusBar();
      } else if (state.currentPlayer === 'black' && !state.gameOver) {
        setTimeout(makeAIMove, 600);
      }
    }

    function squareToAlgebraic(r, c) {
      return `${String.fromCharCode(97 + c)}${8 - r}`;
    }

    function getKingPosition(board, isWhite) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const p = board[r][c];
          if (p && p.toLowerCase() === 'k' && (isWhite ? p === 'k' : p === 'K')) {
            return [r, c];
          }
        }
      }
      return null;
    }

    function isInCheck(board, isWhite) {
      const kingPos = getKingPosition(board, isWhite);
      if (!kingPos) return false;
      const [kr, kc] = kingPos;
      const opponentMoves = getAllPseudoLegalMoves(board, !isWhite, null, null);
      return opponentMoves.some(m => m.to[0] === kr && m.to[1] === kc);
    }

    function isSquareAttacked(board, row, col, attackerWhite) {
      const attacks = getAllPseudoLegalMoves(board, attackerWhite, null, null);
      return attacks.some(m => m.to[0] === row && m.to[1] === col);
    }

    function checkGameEnd(isWhite) {
      const moves = getAllLegalMoves(state.board, isWhite, state.enPassantTarget, state.castlingRights);
      if (moves.length === 0) {
        return isInCheck(state.board, isWhite) ? 'checkmate' : 'stalemate';
      }
      return 'ongoing';
    }

    function explainMove(p) {
      const msgs = {
        p: "Artist advancing toward audience.",
        r: "Gatekeeper controlling market access.",
        n: "Legal maneuver creating pathways.",
        b: "Award influence shifting status.",
        q: "Media amplifying reach.",
        k: "Government setting rules."
      };
      return msgs[p.toLowerCase()] || "Move played.";
    }

    function updateMoveList() {
      const box = document.getElementById('moveList');
      if (state.history.length === 0) {
        box.innerHTML = '<div style="color:#999;font-style:italic;">No moves yet</div>';
        return;
      }
      box.innerHTML = '';
      state.history.forEach((mv, i) => {
        const el = document.createElement('div');
        el.className = 'move-item';
        el.textContent = `${i + 1}. ${mv}`;
        box.appendChild(el);
      });
      box.scrollTop = box.scrollHeight;
    }

    function updateStatusBar() {
      const bar = document.getElementById('statusBar');
      if (state.gameOver) {
        bar.textContent = 'Game Over';
        bar.style.background = '#ffcdd2';
      } else {
        bar.textContent = state.currentPlayer === 'white' ? '‚ö™ White to move' : '‚ö´ Black to move';
        bar.style.background = '#f0f0f0';
      }
    }

    function updateAIStatus() {
      const persona = aiPersonalities[document.getElementById('aiPersonality').value];
      setThinking(`${persona.name}: ${persona.style}`);
    }

    function setThinking(msg) {
      document.getElementById('aiThinking').textContent = msg;
    }

    function evaluateBoard(board, persona) {
      const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
      let score = 0;
      for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
        const p = board[r][c];
        if (!p) continue;
        const isWhite = p === p.toLowerCase();
        const value = pieceValues[p.toLowerCase()];
        score += isWhite ? -value : value;
        if (persona.focus === 'control') {
          const center = 4 - (Math.abs(r - 3.5) + Math.abs(c - 3.5));
          score += (isWhite ? -1 : 1) * center * 10;
        }
      }
      if (persona.focus === 'innovation') score += (Math.random() - 0.5) * 50;
      return score;
    }

    function minimax(board, depth, alpha, beta, maximizingPlayer, persona, enPassantTarget, castlingRights) {
      if (depth === 0) return evaluateBoard(board, persona);
      
      const isWhite = !maximizingPlayer;
      const legalMoves = getAllLegalMoves(board, isWhite, enPassantTarget, castlingRights);
      
      if (legalMoves.length === 0) return maximizingPlayer ? -Infinity : Infinity;

      if (maximizingPlayer) {
        let maxEval = -Infinity;
        for (const move of legalMoves) {
          const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(board, move);
          const evaluation = minimax(newBoard, depth - 1, alpha, beta, false, persona, newEnPassantTarget, newCastlingRights);
          maxEval = Math.max(maxEval, evaluation);
          alpha = Math.max(alpha, evaluation);
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const move of legalMoves) {
          const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(board, move);
          const evaluation = minimax(newBoard, depth - 1, alpha, beta, true, persona, newEnPassantTarget, newCastlingRights);
          minEval = Math.min(minEval, evaluation);
          beta = Math.min(beta, evaluation);
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function makeAIMove() {
      if (state.aiThinking || state.gameOver || state.currentPlayer !== 'black') return;
      
      state.aiThinking = true;
      setThinking("ü§î AI analyzing...");

      const persona = aiPersonalities[document.getElementById('aiPersonality').value];
      const legalMoves = getAllLegalMoves(state.board, false, state.enPassantTarget, state.castlingRights);
      
      if (!legalMoves.length) {
        state.aiThinking = false;
        setThinking("No moves available");
        return;
      }

      let bestMove = null;
      let bestScore = -Infinity;
      
      for (const move of legalMoves) {
        const {newBoard, newEnPassantTarget, newCastlingRights} = applyMoveToBoard(state.board, move);
        const score = minimax(newBoard, persona.depth - 1, -Infinity, Infinity, false, persona, newEnPassantTarget, newCastlingRights);
        if (score > bestScore) {
          bestScore = score;
          bestMove = move;
        }
      }

      if (bestMove) {
        applyMove(bestMove);
        updateAIStatus();
      }
      
      state.aiThinking = false;
    }

    function resetGame() {
      state.history = [];
      state.currentPlayer = 'white';
      state.gameOver = false;
      state.firstMoveMade = false;
      state.selected = null;
      state.validMoves = [];
      state.aiThinking = false;
      state.castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
      state.enPassantTarget = null;
      document.getElementById('aiPersonality').disabled = false;
      buildBoard();
      setupPieces();
      drawAll();
      updateAIStatus();
      pushEdu("üéÆ New game started. You control White (Artists). Click a piece to select it.");
    }

    function pushEdu(msg) {
      const wrap = document.getElementById('educationalContent');
      const d = document.createElement('div');
      d.className = 'insight';
      d.innerHTML = `<p>${msg}</p>`;
      const olds = wrap.querySelectorAll('.insight');
      if (olds.length >= 5) olds[0].remove();
      wrap.appendChild(d);
      wrap.scrollTop = wrap.scrollHeight;
    }
  </script>
</body>
</html>
